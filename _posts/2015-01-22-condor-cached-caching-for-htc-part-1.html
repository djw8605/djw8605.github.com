---
title: 'Condor CacheD: Caching for HTC - Part 1'
date: '2015-01-22T10:00:00.000-06:00'
author: Derek Weitzel
tags:
- osg
- condor
modified_time: '2015-01-27T09:37:00.420-06:00'
blogger_id: tag:blogger.com,1999:blog-3007054864987759910.post-1889975382858537261
blogger_orig_url: http://derekweitzel.blogspot.com/2015/01/condor-cached-caching-for-htc-part-1.html
---

A typical job flow in the Open Science Grid is as follows:<br /><ol><li>Stage input files to worker node.</li><li>Start processing...</li><li>Stage output files back to submit host.</li></ol><div>In an ideal world, step 2 would take the longest. &nbsp;But, as data sizes increase, so to does the stage-in and stage-out of the files (primarily the stage-in). &nbsp;Additionally, we continue to recommend the same maximum job length to users, around 8 hours. <br /><br />Lets use a real world example. &nbsp;The nr blast database (Non-redundant GenBank CDS translations + PDB + SwissProt + PIR + PRF, excluding those in env_nr<span style="background-color: white; color: #333333; font-family: arial, tahoma, verdana, sans-serif; font-size: 13px; line-height: 19.9200000762939px;">) (<a href="http://blast.ncbi.nlm.nih.gov/Blast.cgi?CMD=Web&amp;PAGE_TYPE=BlastDocs&amp;DOC_TYPE=ProgSelectionGuide">source</a>)</span>&nbsp;is currently ~15GB. &nbsp;When running blast, each query needs to run over the entire nr database, therefore it is required on every worker node that will run the query.<br /><br />It is easy to say... well a 1 Gbps connection can transfer 15GB in ~120 seconds. &nbsp;Two minutes doesn't seem unreasonable to stage-in data, especially if the job can be 8 hours long. &nbsp;But usually you have many queries, so you will want to run these queries across many jobs. &nbsp;So lets say you submit 10 jobs, each needing the 15GB. &nbsp;Well, that should mean that if they all transfer at the same time, it will take 20 minutes of stage in time before any processing begins. &nbsp;But that is only for 10 jobs, what if you are submitting 1,000 jobs, or 10,000 jobs? &nbsp;At 1,000 jobs, it takes 33 hours to transfer data for input files? &nbsp;Suddenly 2 minutes to transfer a database becomes hours. &nbsp;And your submit machine is doing nothing but transferring input files! &nbsp;Also, using some math (or a simple <a href="http://nbviewer.ipython.org/gist/djw8605/144729e82f0ef8313f6d">simulation</a>), you can see that if the jobs start sequentially, you are limited on the number of jobs that can run simultaneously.<br /><br />This increasing data size and static maximum job length have lead to compromises and innovations on the part of users and sites.<br /><br /><h4>Innovations</h4></div><div>Some users and sites have attempted to solve the larger input files. &nbsp;They can be typically broken into two categories:</div><div><ol><li>Bandwidth increases from the storage nodes.</li><li>Caching near the execution host.</li></ol><div><br /></div></div><div><h3>Lots O' Bandwidth</h3><a href="http://osgconnect.net/">OSG Connect's</a>&nbsp;<a href="http://stash.osgconnect.net/">Stash</a> attempts to ease the input file stage problem by providing a storage service with lots of bandwidth (10 Gbps), and support for site caching through HTTP. &nbsp;Certainly the higher bandwidth solution is the brute force method of decreasing the transfer time for files. &nbsp;But, 10 Gbps only knocks off a factor of 10 from all of the above times. &nbsp;This will certainly decrease the transfer time, but only if you can use all 10 Gbps.<br /><br />Numerous sites and users have tried to use high bandwidth storage services to solve the stage-in problem. &nbsp;Nebraska (and many other sites) even have their storage services connected to 100 Gbps network connections. &nbsp;But they tend to be limited not by the bandwidth available to the storage device, but by the bandwidth bottleneck at the boundary of each cluster to the outside world, usually a NAT.<br /><br /></div><div><h3>Caching</h3></div><div>With Stash's HTTP interface, users can use local site caching. &nbsp;When the site caching was designed, it was meant to be used for calibration data for detectors. &nbsp;This tends to be rather small data that is frequently accessed, the perfect use of a HTTP cache. &nbsp;But what about when you want to transfer 15GBs of files through the HTTP cache? &nbsp;A typical site may only have a few cache servers, therefore limiting the bandwidth available to download not on the available bandwidth of the hosting server, but the available bandwidth on the cache servers. &nbsp;I don't know of many sites that are putting 10Gbps connections on their caching servers.<br /><br />Additionally, site caching simply runs from the submit host to the remote caching host. &nbsp;In the last week, the 95% of OSG VO's CPU hours have been provided by ~25 unique sites (<a href="http://gratiaweb.grid.iu.edu/gratia/xml/facility_hours_bar_smry?facility=.*&amp;probe=.*&amp;resource-type=%5EBatch%24&amp;vo=osg&amp;user=.*&amp;endtime=2015-01-21+23%3A59%3A59&amp;exclude-vo=Unknown%7Cunknown%7Cother&amp;includeFailed=true&amp;exclude-role=NONE&amp;span=86400&amp;vo_set=%5Eosg%24&amp;role=.*&amp;starttime=2015-01-07+00%3A00%3A00&amp;exclude-facility=NONE%7CGeneric%7CObsolete&amp;exclude-user=NONE&amp;includeSuccess=true">source</a>, <a href="https://docs.google.com/spreadsheets/d/1hcOHDaXR-l78pufw4lM_dkAL1nIO68E6Rx0Cp1nOVrM/edit?usp=sharing">calculations</a>). &nbsp;This analogous to increasing the bandwidth of the submit host by 25 times (assuming 1gbps connections standard). &nbsp;This is a very cheap way to increase the bandwidth available to transfer &nbsp;input files. &nbsp;But the VO's usage is not split evenly amongst all 25 sites. &nbsp;6 sites account for ~50% of the OSG VO usage. &nbsp;On those 6 clusters, the transfer bandwidth is limited to what those 6 proxy servers can transfer to their cluster's nodes. &nbsp;Therefore, for 50% of your processing slots, you are only increasing the transfer speed by 6.</div><div><br /></div><div>The HTTP protocol and HTTP caching is not designed for such large files. &nbsp;HTTP will always be designed for the dominant users, browsers downloading relatively small webpages. &nbsp;Software designed to use HTTP are optimized for web sites, lots of small files. &nbsp;Therefore, any software that might be used in conjunction with HTTP may not be ideal for large files.</div><div><br /></div><h4>A New Hope</h4><div>Part of my PhD has been to develop a new way to handle large stage-in datasets. &nbsp;In the above problem statement, two areas where most often used to optimize transfer times, bandwidth and caching. &nbsp;My attempts to optimize both of these approaches using a daemon named the HTCondor CacheD.<br /><br /><h3>Bandwidth</h3></div><div>As noted above, HTTP is great for it's designed use: websites with lots of small files. &nbsp;But it is not designed or well optimized for larger files. &nbsp;Further, the bandwidth from the execution host to the storage servers are typically bottlenecked at the cluster boundary. &nbsp; Therefore another protocol was chosen that could better handle large files, BitTorrent.</div><br /><a href="https://en.wikipedia.org/wiki/BitTorrent">BitTorrent</a>&nbsp;was chosen since it contains many characteristics that make it ideal for transferring large files. &nbsp;In order to bypass the network bottlenecks in the remote clusters, BitTorrent allows for clients to transfer data between them while also downloading from the original source. &nbsp;This allows every worker node to become a cache for the rest of the cluster nodes. &nbsp;As we will see in the next post, BitTorrent works well because the vast majority of the traffic is between nodes inside the cluster, rather than to nodes outside the cluster.<br /><br /><h3>Caching</h3><div>The caching described above utilized a single cache on each site. &nbsp;From the usage breakdown, you can see that VO's that rely on few sites will find this a bottleneck. &nbsp;For campus users, which may only use 1 or 2 clusters, this can be as bad of a bottleneck as not using a cache at all. &nbsp;Also, this requires the site to have a caching server setup, which requires administrator cooperation.<br /><br />The CacheD instead uses local caches on each worker node. &nbsp;This local cache allows very fast transfers when the jobs begin. &nbsp;Further, the local cache acts as a seeder for the BitTorrent transfers described above.<br /><br />When a job is begins running on a node, the stage-in stage will request from the local cache a copy of the data files. &nbsp;If the data files are not already staged at the local node, the local cache will pull the data files using BitTorrent from the submit host (cache origin) and all other nodes in the cluster. &nbsp;When the local cache has cached the stage-in data files, it will transfer the cached files into the jobs sandbox and begin processing. &nbsp;Subsequent jobs that require the same stage-in data files will request then immediately receive the files since they are already cached locally.</div><div><br /></div><h4>Up Next</h4><div>In the next post, I will describe the design of the CacheD in more detail. &nbsp;Further, I will show usage of the CacheD with blast databases, and the improvement in job startup time resulting in optimized stage-in transfers.<br /><br />UPDATE: Link to Part 2, <a href="http://derekweitzel.blogspot.com/2015/01/htcondor-cached-caching-for-htc-part-2.html">Architecture of the CacheD</a>.</div><br />
