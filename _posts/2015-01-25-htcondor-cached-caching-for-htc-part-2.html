---
title: 'HTCondor CacheD: Caching for HTC - Part 2'
date: '2015-01-25T09:59:00.000-06:00'
author: Derek Weitzel
tags:
- osg
- condor
modified_time: '2015-01-25T09:59:00.202-06:00'
thumbnail: http://4.bp.blogspot.com/-0t61LNEhNP8/VMK3q55wm3I/AAAAAAAAC28/CdyFV9FXD3I/s72-c/CachedInitialization.png
blogger_id: tag:blogger.com,1999:blog-3007054864987759910.post-5260378956420164105
blogger_orig_url: http://derekweitzel.blogspot.com/2015/01/htcondor-cached-caching-for-htc-part-2.html
---

In the <a href="http://derekweitzel.blogspot.com/2015/01/condor-cached-caching-for-htc-part-1.html">previous post</a>, I discussed why we decided to make the HTCondor CacheD. &nbsp;This time, we will discuss the operation and design of the CacheD, as well as show an example utilizing a BLAST database.<br /><br />It is important to note that the CacheD is still very much "dissertation-ware." &nbsp;It functions enough to demonstrate the improvements, but not enough to be put into production.<br /><br /><h4>The Cache</h4><div>The fundamental unit that the CacheD works with is an immutable set of files in a cache. &nbsp;A user creates and uploads files into the cache. &nbsp;Once the upload is complete, the cache is committed and may not be altered at any time. &nbsp;The cache has a set of metadata associated with it as well, stored as classads in a durable storage database (using the same techniques as the SchedD job queue).</div><div><br /></div><div>The cache has a 'lease', or an expiration date. &nbsp;This lease is a given amount of time that the cache is guaranteed to be available from a particular CacheD. &nbsp;When creating the cache, the user provides a requested cache lifetime. &nbsp;The CacheD can either accept or reject the requested cache lifetime. &nbsp;Once the cache's lifetime expires, it can be deleted by the CacheD and is no longer guaranteed to be available. &nbsp;The user may request to extend the lifetime of a cache after it has already been committed, which the CacheD may or may not accept.</div><div><br /></div><div>The cache also has properties similar to a job. &nbsp;For example, the cache can have it's own set of requirements for which nodes it can be replicated to. &nbsp;By default, a cache is initialized with the requirement that a CacheD has enough disk space to hold the cache. &nbsp;Analogous to the HTCondor matching with jobs, the cache can have requirements, and the CacheD can have requirements. &nbsp;A CacheD requirements may be that the node has enough disk space to hold the matched cache. &nbsp;This two way matching guarantees that any local policies are enforced.</div><div><br /></div><div>The requirements attribute is especially useful when the user aligns the cache's requirements with the jobs that require the data. &nbsp;For example, if the user knows that their processing requires nodes with 8GB of ram available, then there is no point is replicating the cache to a node with less than 8GB of ram.</div><div><br /></div><h4>The CacheD</h4><div>The CacheD is the daemon that manages caches on the local node. &nbsp;Each CacheD is considered a peer to all other CacheD's, there is no further coordination daemon. &nbsp;Each cache serves multiple functions:</div><div><ol><li>Respond to user requests to create, query, update, and delete caches.</li><li>Send replication requests to CacheD's that match each cache's requirements.</li><li>Respond to replication requests from other CacheD's. &nbsp;Matching is done on the cache before transferring the data</li></ol><div>The CacheD keeps a database storing the metadata for each cache. &nbsp;The database is stored using the same techniques as the SchedD uses for jobs to maintain a durable database store. &nbsp;It also maintains a directory containing all of the caches stored on the node.</div></div><div><br /></div><div>The CacheD's user interface is primarily through python bindings, at least for the time being.</div><div><br /></div><h4>CacheD Usage</h4><div>The CacheD is used in conjunction with glideins. &nbsp;The CacheD is started along with other glidein daemons such as the HTCondor StartD.</div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-0t61LNEhNP8/VMK3q55wm3I/AAAAAAAAC28/CdyFV9FXD3I/s1600/CachedInitialization.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://4.bp.blogspot.com/-0t61LNEhNP8/VMK3q55wm3I/AAAAAAAAC28/CdyFV9FXD3I/s1600/CachedInitialization.png" height="344" width="640" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Initialization of cache as well as initial replication requests</td></tr></tbody></table><div>The user initializes the cache by creating and uploading it to the user's submit machine. &nbsp;The CacheD connects to remote CacheD's, sending replication requests.</div><div class="separator" style="clear: both; text-align: center;"></div><div><br /></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-aZhjvd3F_M0/VMK8YMswJ9I/AAAAAAAAC3M/_pCf-OX1Q8k/s1600/CachedReplication.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://1.bp.blogspot.com/-aZhjvd3F_M0/VMK8YMswJ9I/AAAAAAAAC3M/_pCf-OX1Q8k/s1600/CachedReplication.png" height="314" width="640" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">The BitTorrent communication between nodes after accepting the replication request</td></tr></tbody></table><div>Once the CacheD's accept the replication request(s), BitTorrent protocol allows for communication between all nodes inside the cluster, as well with the user's submit machine. &nbsp;This graph only shows a single cluster, but this could be replicated to many clusters as well.</div><div><br /></div><h4>In Action&nbsp;</h4><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-AVc8_0W-tSk/VMLASPT5t8I/AAAAAAAAC3U/IDN7RG2DvkI/s1600/verbose_group.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-AVc8_0W-tSk/VMLASPT5t8I/AAAAAAAAC3U/IDN7RG2DvkI/s1600/verbose_group.png" height="308" width="640" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Partial graph showing data transfers. &nbsp;Due to overflowing the event queue, not all downloads are captured.</td></tr></tbody></table><div>The above graph shows the data transfer using the BitTorrent protocol between the nodes that have accepted the replication request and the Cache Origin, which is an external node. &nbsp;In this example, only 5 remote CacheD's where started on the cluster. &nbsp;Because of all of the traffic between nodes, this level of detail graph becomes unreadable very quickly when increasing the number of remote CacheD's.</div><div><br /></div><div>You will notice that the Cache Origin only transfers to 2 nodes inside the cluster. &nbsp;The BitTorrent protocol is complicated and difficult to predict, therefore this could be caused by many factors. &nbsp;For example, the two nodes could have found the CacheD origin first, therefore being the first nodes to download it. &nbsp;The other nodes would then have found the internal cluster nodes with portions of the cache, and begun to download from it.<br /><br />It is important to note that even though the ~15GB cache is transferred to all 5 nodes, totalling 75GB of transferred cache, only ~15Gb is transferred from the cache origin, and all of the rest of the transfers are between nodes in the cluster.<br /><br /><h4>Up Next</h4></div><div>In Part 3 of the series, I will look at timings of the transfers using data analysis of trial runs. &nbsp;As a hint, the BitTorrent protocol is slower than direct transfers for 1 to 1 transfers. &nbsp;But it really shines when increasing the number of downloaders and seeders.</div><div><br /></div>
